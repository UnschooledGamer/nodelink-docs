---
title: Docker
description: Ship your audio server in a container. Same code, anywhere. üê≥
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { Steps, Step } from 'fumadocs-ui/components/steps';
import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';
import { Card, Cards } from 'fumadocs-ui/components/card';

# Docker: Because Production Should Just Work

Look, we've all been there. You spend hours getting NodeLink running perfectly on your laptop. Everything works. Audio is crisp. No crashes. Life is good.

Then you deploy to production and... it doesn't work. Wrong Node version. Missing dependencies. Something about native modules. Your weekend is gone.

**Docker fixes this.** It's not magic. It's just consistency. Same environment, same dependencies, same behavior‚Äîwhether you're running on your gaming PC, a $5 VPS, or an enterprise Kubernetes cluster.

<Callout type="info" title="What Docker Actually Does">
  Docker wraps your application with everything it needs (Node.js, system libraries, native modules) into an image. That image runs the same way everywhere. No surprises. No "works on my machine" excuses.
</Callout>

---

## Why Bother With Containers?

Because you have better things to do than fight with package managers at 3 AM trying to get `sodium-native` to compile.

Docker gives you instant setup where you don't need to manually install Node.js v22+. No hunting down build tools for native modules. No dependency resolution nightmares. Just pull the image and run. Your NodeLink instance lives in perfect isolation, in its own world where it can't interfere with your system and nothing can interfere with it. Clean slate every time you start it.

Updates become trivial. New version? Just `docker compose pull && docker compose up -d` and you're done. Need to rollback? Same commands, different tag. The portability is real too‚Äîit runs on Linux, Windows, macOS, ARM, x86, cloud, bare metal. If Docker exists there, NodeLink runs there.

<Cards>
  <Card title="Zero Native Build Issues">
    Native modules like `sodium-native` for encryption are already compiled in the image. No gcc, no python, no build-essential needed.
  </Card>
  <Card title="Worker Architecture Ready">
    The image is optimized for NodeLink's worker-based architecture. Cluster mode works out of the box without manual configuration.
  </Card>
  <Card title="Production Hardened">
    Health checks, restart policies, and security best practices are configured. Not something you cobbled together from a tutorial.
  </Card>
  <Card title="True Portability">
    The same image that runs on your laptop runs in production. No environment-specific bugs. No surprise differences.
  </Card>
</Cards>

---

## The Setup Is Already Done

The NodeLink repository includes a production-ready Docker setup. No assembly required.

We already built a multi-stage `Dockerfile` that compiles native modules in a build stage and copies only what's needed to the runtime stage. The result is a lean image optimized for size and security. The `docker-compose.yml` includes every single configuration option NodeLink supports, all documented inline with examples. Health checks verify NodeLink is actually responding, not just that the container is running. Restart policies ensure it comes back up automatically if it crashes. Volume mounts are configured for local music files and log persistence.

You don't need to piece this together yourself. You don't need to understand Docker internals. Just clone the repo, adjust the handful of settings that matter to you, and launch.

---

## Getting Started

<Steps>

<Step>

### Install Docker

You need Docker and Docker Compose. If you don't have them yet, get them from the official sources.

<Tabs items={['Linux', 'Windows', 'macOS']}>
  <Tab value="Linux">
    For Ubuntu/Debian, use the official Docker repository for the latest version:
    
    ```bash
    # Add Docker's official GPG key
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
    
    # Add Docker repository
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
    
    # Install Docker Engine
    sudo apt update
    sudo apt install docker-ce docker-ce-cli containerd.io docker-compose-plugin
    ```
    
    For other distributions, check the [official installation guide](https://docs.docker.com/engine/install/).
  </Tab>
  <Tab value="Windows">
    Download and install **Docker Desktop for Windows** from [docker.com](https://www.docker.com/products/docker-desktop/).
    
    Docker Desktop includes both Docker Engine and Docker Compose. After installation, you'll need to restart your computer.
    
    Make sure WSL2 is enabled if you're on Windows 10/11. Docker Desktop will prompt you to install it if needed.
  </Tab>
  <Tab value="macOS">
    Download and install **Docker Desktop for Mac** from [docker.com](https://www.docker.com/products/docker-desktop/).
    
    Docker Desktop includes both Docker Engine and Docker Compose. Works on both Intel and Apple Silicon Macs.
  </Tab>
</Tabs>

Verify everything is working:

```bash
docker --version
docker compose version
```

If both commands output version numbers, you're ready.

</Step>

<Step>

### Clone NodeLink

Get the repository to your machine:

```bash
git clone https://github.com/PerformanC/NodeLink.git
cd NodeLink
```

You now have everything. The Dockerfile, the docker-compose.yml, all of it.

</Step>

<Step>

### Configure Your Instance

Open `docker-compose.yml` in your editor. You'll see a massive file with every configuration option documented. Most of it you can leave as-is. Here's what you **must** change:

```yaml
environment:
  NODELINK_SERVER_PASSWORD: "youshallnotpass" # ‚ö†Ô∏è CHANGE THIS NOW
```

<Callout type="warn" title="Don't Skip This">
  Using the default password in production is like leaving your front door open with a sign that says "free stuff inside." Change it. Use something long and random.
</Callout>

**Optional but recommended** configurations depend on what you need:

If you want **Spotify support**, you'll need credentials from the Spotify Developer Dashboard:

```yaml
NODELINK_SOURCES_SPOTIFY_ENABLED: "true"
NODELINK_SOURCES_SPOTIFY_CLIENTID: "your_actual_spotify_client_id"
NODELINK_SOURCES_SPOTIFY_CLIENTSECRET: "your_actual_spotify_client_secret"
```

If you want better **YouTube support** (help with age-restricted content and some geographically restricted content), the default remote server is `cipher.kikkia.dev`:

```yaml
NODELINK_SOURCES_YOUTUBE_CIPHER_TOKEN: "your_cipher_token" #If you are using an internal or different server, you must provide the corresponding authorization for it.
```

If you want to **use all your CPU cores** for better performance under load, enable cluster mode:

```yaml
NODELINK_CLUSTER_ENABLED: "true"
NODELINK_CLUSTER_WORKERS: "0" # 0 means use all available CPU cores
```

Everything else has sensible defaults. You can explore the 200+ other options in the file when you need them.

</Step>

<Step>

### Launch It

One command:

```bash
docker compose up -d
```

Docker will build the NodeLink image from the Dockerfile, compile native modules, install dependencies, and start the server. The `-d` flag runs it in detached mode (background).

This takes a few minutes the first time while it builds the image. Subsequent starts are instant.

</Step>

<Step>

### Verify It's Alive

Check if NodeLink is responding:

```bash
curl http://localhost:2333/version
```

You should see version information. If you do, NodeLink is running and ready to connect to your Discord bot.

If something went wrong, check the logs:

```bash
docker compose logs -f nodelink
```

The `-f` flag follows the logs in real-time. Press Ctrl+C to exit.

</Step>

</Steps>

---

## Understanding the Configuration

The `docker-compose.yml` file is massive because it exposes every single configuration option NodeLink supports as environment variables. Most of them you'll never touch. Here's what's actually in there:

<Accordions>

<Accordion title="Server Basics">

These control where NodeLink listens and how clients authenticate:

```yaml
NODELINK_SERVER_HOST: "0.0.0.0"  # Listen on all interfaces
NODELINK_SERVER_PORT: "2333"      # Default Lavalink port
NODELINK_SERVER_PASSWORD: "youshallnotpass"  # Change this
```

The host `0.0.0.0` means NodeLink accepts connections from anywhere. If you only want localhost access, use `127.0.0.1`. The port `2333` is the standard Lavalink port. Most clients expect this, but you can change it if needed.

</Accordion>

<Accordion title="Cluster Mode for Performance">

NodeLink uses a worker-based architecture where heavy tasks like playlist parsing happen in separate processes. This keeps your main audio loop smooth. Cluster mode takes this further by running multiple worker processes:

```yaml
NODELINK_CLUSTER_ENABLED: "true"
NODELINK_CLUSTER_WORKERS: "0"           # 0 = use all CPU cores
NODELINK_CLUSTER_MINWORKERS: "1"
NODELINK_CLUSTER_MAXPLAYERSPERWORKER: "20"
```

Why cluster mode? Better CPU utilization across cores. Auto-scaling where workers spawn and die based on player load. Reliability where one worker crashing doesn't take down the whole server. Set `WORKERS` to `0` and NodeLink automatically uses all your cores. Or specify a number like `4` for exactly 4 workers.

</Accordion>

<Accordion title="Audio Sources">

NodeLink supports multiple audio sources. Each can be enabled or disabled independently:

**YouTube** (enabled by default, the backbone of most music bots):

```yaml
NODELINK_SOURCES_YOUTUBE_ENABLED: "true"
NODELINK_SOURCES_YOUTUBE_CIPHER_TOKEN: ""  # Optional, helps with some restricted content
```

**Spotify** (requires API credentials):

```yaml
NODELINK_SOURCES_SPOTIFY_ENABLED: "true"
NODELINK_SOURCES_SPOTIFY_CLIENTID: "your_id"
NODELINK_SOURCES_SPOTIFY_CLIENTSECRET: "your_secret"
```

**Local files** (play music from your server's filesystem):

```yaml
NODELINK_SOURCES_LOCAL_ENABLED: "true"
NODELINK_SOURCES_LOCAL_BASEPATH: "/app/music/"
```

**Others**: SoundCloud, Deezer, Apple Music, Tidal, Bandcamp, Twitch, Nico Nico, and more. All in the config file. All documented inline. Most work without additional setup.

</Accordion>

<Accordion title="Audio Filters">

NodeLink includes audio filters for real-time audio modification. Standard filters like Equalizer, Karaoke, Timescale, Tremolo, Vibrato, Rotation, Distortion, and Channel Mix are all enabled by default. NodeLink-exclusive filters like Echo, Chorus, Compressor, High Pass, Phaser, and Spatial are also available.

All filters are processed natively without external tools. Want to disable a specific filter? Just set it to false:

```yaml
NODELINK_FILTERS_ENABLED_ECHO: "false"
```

You can combine multiple filters simultaneously. NodeLink processes them efficiently in the audio pipeline without significant overhead.

</Accordion>

<Accordion title="Lyrics Integration">

NodeLink tries multiple lyric sources automatically in order until one succeeds:

```yaml
NODELINK_LYRICS_YOUTUBE_ENABLED: "true"      # Synced captions when available
NODELINK_LYRICS_GENIUS_ENABLED: "true"        # Plain text lyrics
NODELINK_LYRICS_MUSIXMATCH_ENABLED: "true"    # Synced lyrics (auto-obtains signature)
NODELINK_LYRICS_LRCLIB_ENABLED: "true"        # Open-source synced lyrics
```

NodeLink tries YouTube first for synced captions. If that fails, it tries Musixmatch. Then LRCLib. Finally Genius. First source that returns lyrics wins. This happens automatically when you request lyrics via the API.

</Accordion>

<Accordion title="Monitoring with Prometheus">

NodeLink can expose Prometheus metrics for production monitoring:

```yaml
NODELINK_METRICS_ENABLED: "true"
NODELINK_METRICS_AUTHORIZATION_TYPE: "Bearer"
NODELINK_METRICS_AUTHORIZATION_PASSWORD: ""  # Empty = use server password
```

<Callout type="warn" title="Optional Dependency Required">
Prometheus metrics require the `prom-client` package to be installed:

```bash
npm install prom-client
```

Without this package, NodeLink will throw an error if metrics are enabled in your configuration. You can disable metrics by setting `metrics.enabled: false` in your config file.
</Callout>

The metrics endpoint becomes available at `/v4/metrics`. Point your Prometheus scraper at it. Get insights into audio frame delivery, memory usage, event loop lag, player counts, and more. See the [Prometheus documentation](/docs/advenced/prometheus) for dashboard examples.

</Accordion>

<Accordion title="Security Features">

NodeLink includes rate limiting and DoS protection out of the box:

```yaml
NODELINK_RATELIMIT_ENABLED: "true"
NODELINK_RATELIMIT_GLOBAL_MAXREQUESTS: "1000"
NODELINK_RATELIMIT_GLOBAL_TIMEWINDOWMS: "60000"  # 1 minute

NODELINK_DOSPROTECTION_ENABLED: "true"
NODELINK_DOSPROTECTION_THRESHOLDS_BURSTREQUESTS: "50"
```

These defaults protect against spam and abuse without affecting normal usage. Global rate limiting caps total requests per IP. DoS protection detects and blocks burst traffic patterns. Both are enabled by default and just work.

</Accordion>

<Accordion title="Logging Configuration">

Control how verbose NodeLink is and where logs go:

```yaml
NODELINK_LOGGING_LEVEL: "info"  # debug, info, warn, error
NODELINK_LOGGING_FILE_ENABLED: "false"
NODELINK_LOGGING_FILE_PATH: "logs"
```

The default `info` level shows important events without noise. Use `debug` when troubleshooting issues. If you enable file logging, mount a volume to persist logs:

```yaml
volumes:
  - ./logs:/app/logs
```

Logs will appear in the `logs` directory on your host machine.

</Accordion>

</Accordions>

---

## Common Operations

Commands you'll use regularly:

<Tabs items={['Start/Stop', 'Logs', 'Updates', 'Shell Access']}>
  <Tab value="Start/Stop">
    ```bash
    # Start NodeLink in background
    docker compose up -d
    
    # Stop NodeLink
    docker compose down
    
    # Restart NodeLink (reload config changes)
    docker compose restart
    
    # Check if running
    docker compose ps
    ```
  </Tab>
  <Tab value="Logs">
    ```bash
    # View logs (follow mode)
    docker compose logs -f nodelink
    
    # View last 100 lines
    docker compose logs --tail=100 nodelink
    
    # View logs from specific time
    docker compose logs --since 30m nodelink
    ```
  </Tab>
  <Tab value="Updates">
    ```bash
    # Update to latest version
    cd NodeLink
    git pull
    docker compose up -d --build
    
    # Or using Docker Hub images
    docker compose pull
    docker compose up -d
    ```
  </Tab>
  <Tab value="Shell Access">
    ```bash
    # Access container shell
    docker compose exec nodelink sh
    
    # Run commands inside container
    docker compose exec nodelink npm run --version
    ```
  </Tab>
</Tabs>

---

## Using Pre-built Images

Don't want to build from source every time? Use the pre-built images from Docker Hub:

```yaml
services:
  nodelink:
    image: performanc/nodelink:latest
    # ... rest of your config ...
```

Available tags:

<Cards>
  <Card title="latest">
    Most recent stable release. Updated with each new version. Safe for production.
  </Card>
  <Card title="v3.1.1">
    Specific version tags. Pin to a version for consistency. Useful when you want predictable behavior.
  </Card>
  <Card title="dev">
    Bleeding edge from main branch. Gets new features first. May break occasionally. Not for production.
  </Card>
</Cards>

Using pre-built images means faster deployments. No compile time. Just pull and run. The tradeoff is slightly larger images since they're built for multiple architectures.

---

## Local Music Files

Want to play music from your server's hard drive? NodeLink's local source lets you stream files directly from the filesystem.

<Steps>

<Step>

### Create Music Directory

Make a folder for your music files:

```bash
mkdir local-music
```

Put your audio files there. NodeLink supports common formats like MP3, FLAC, WAV, OGG, M4A, and more.

</Step>

<Step>

### Mount Volume

Edit your `docker-compose.yml` to mount the directory:

```yaml
services:
  nodelink:
    volumes:
      - ./local-music:/app/music
    environment:
      NODELINK_SOURCES_LOCAL_ENABLED: "true"
      NODELINK_SOURCES_LOCAL_BASEPATH: "/app/music/"
```

The volume mount makes your `local-music` folder appear inside the container at `/app/music`. The basepath tells NodeLink where to look for files.

</Step>

<Step>

### Load Tracks

Restart NodeLink to apply changes:

```bash
docker compose restart
```

Now you can load tracks using the `file://` protocol:

```
file:///app/music/song.mp3
file:///app/music/albums/album1/track.flac
```

The path must start with the basepath you configured. NodeLink resolves the file and streams it like any other source.

</Step>

</Steps>

<Callout title="Security Note">
  Local file access is powerful but requires careful configuration. NodeLink validates paths to prevent directory traversal attacks. Still, only enable this if you control the filesystem and know who can access the API.
</Callout>

---

## Production Deployment

Running NodeLink in production requires a few extra considerations beyond just starting the container.

### Reverse Proxy Setup

NodeLink should sit behind a reverse proxy in production for SSL termination and security. Here's an Nginx example:

```nginx
server {
    listen 80;
    server_name audio.yourdomain.com;
    
    # Redirect HTTP to HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name audio.yourdomain.com;
    
    # SSL certificates (use certbot for Let's Encrypt)
    ssl_certificate /etc/letsencrypt/live/audio.yourdomain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/audio.yourdomain.com/privkey.pem;
    
    location / {
        proxy_pass http://localhost:2333;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # WebSocket support
        proxy_read_timeout 86400;
    }
}
```

This configuration handles HTTPS, WebSocket upgrades, and proper header forwarding. Get SSL certificates from Let's Encrypt using certbot. It's free and automated.

### Resource Limits

Prevent NodeLink from consuming all system resources if something goes wrong:

```yaml
services:
  nodelink:
    deploy:
      resources:
        limits:
          cpus: '2.0'      # Max 2 CPU cores
          memory: 2G       # Max 2GB RAM
        reservations:
          cpus: '0.5'      # Reserve half a core
          memory: 512M     # Reserve 512MB RAM
```

These limits depend on your player count. More simultaneous players need more resources. Monitor actual usage and adjust accordingly.

### Health Checks

Docker can monitor if NodeLink is actually responding, not just that the container is running:

```yaml
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:2333/version"]
  interval: 30s
  timeout: 10s
  retries: 3
  start_period: 40s
```

If the health check fails three times, Docker marks the container as unhealthy. Combined with restart policies, this provides automatic recovery from crashes or hangs.

### Firewall Configuration

If NodeLink runs on a remote server, allow incoming connections:

```bash
# UFW (Ubuntu/Debian)
sudo ufw allow 2333/tcp

# firewalld (CentOS/RHEL)
sudo firewall-cmd --add-port=2333/tcp --permanent
sudo firewall-cmd --reload
```

Only open ports you actually use. If NodeLink is behind a reverse proxy, you might only need to open 80/443 for the proxy and keep 2333 local-only.

### Security Checklist

Before going live, verify these points:

<Accordions>
  <Accordion title="Authentication">
    - [ ] Changed default password to something strong and random
    - [ ] Server password is not committed to version control
    - [ ] Metrics endpoint uses separate authentication if exposed publicly
  </Accordion>
  <Accordion title="Network Security">
    - [ ] NodeLink is behind HTTPS reverse proxy
    - [ ] Firewall rules limit access to only necessary ports
    - [ ] Rate limiting is enabled
    - [ ] DoS protection is enabled
  </Accordion>
  <Accordion title="Operational Security">
    - [ ] Health checks are configured
    - [ ] Restart policy is set to handle crashes
    - [ ] Logs are being collected somewhere
    - [ ] Resource limits prevent runaway usage
    - [ ] Backups exist for configuration
  </Accordion>
</Accordions>

---

## Troubleshooting

### Container Won't Start

Check the logs for specific errors:

```bash
docker compose logs nodelink
```

Common problems and fixes:

**Port already in use**: Something else is listening on 2333. Either stop that process or change NodeLink's port in `docker-compose.yml`:

```yaml
ports:
  - "2334:2333"  # Use 2334 externally, 2333 internally
```

**Permission denied**: Docker doesn't have permission to bind the port or access volumes. On Linux, add your user to the docker group:

```bash
sudo usermod -aG docker $USER
```

Log out and back in for the change to take effect.

**Invalid configuration**: Check for typos in `docker-compose.yml`. YAML is whitespace-sensitive. Use a validator if unsure.

### Can't Connect from Discord Bot

First, verify NodeLink is accessible from outside the container:

```bash
curl http://your-server-ip:2333/version
```

If this fails, check your firewall rules. If it succeeds but your bot still can't connect, verify the password matches between your bot config and `docker-compose.yml`.

For remote servers, ensure the firewall allows incoming connections:

```bash
sudo ufw status
```

The port (default 2333) should be listed as allowed.

### High CPU Usage

Check how many players are active:

```bash
curl http://localhost:2333/v4/stats -H "Authorization: yourPassword"
```

Look at the `players` and `playingPlayers` counts. High CPU with many players is normal. If CPU is high with few players, enable cluster mode:

```yaml
NODELINK_CLUSTER_ENABLED: "true"
NODELINK_CLUSTER_WORKERS: "0"  # Use all cores
```

Restart after changing the config.

### Audio Cutting Out

This usually indicates network issues or event loop blocking. Check frame statistics in the stats endpoint:

```bash
curl http://localhost:2333/v4/stats -H "Authorization: yourPassword"
```

Look at `frameStats`. If `deficit` is positive or `nulled` is increasing, audio is being dropped. Try increasing the update interval:

```yaml
NODELINK_PLAYERUPDATEINTERVAL: "1000"
```

Also check network latency between your server and Discord voice servers. High latency causes problems.

### Memory Growing Over Time

External memory grows with active players. This is normal. Each player holds audio buffers for smooth playback. Memory should stabilize once player count is constant. If memory keeps growing even without new players, that might indicate a leak. Report it with logs and reproduction steps.

---

## The Real Talk

Docker makes deploying NodeLink almost trivial. You don't need to be a DevOps expert. You don't need to understand multi-stage builds or image layers or any of that.

The repository already has everything configured. A production-ready Dockerfile optimized for NodeLink's native modules and worker architecture. A comprehensive docker-compose.yml with every option documented. Health checks and restart policies. Security features enabled by default.

Just clone it, change the password, and run `docker compose up -d`. That's literally the deployment process.

Everything else in this document is optional. The defaults work. The configuration makes sense. The security is reasonable. You can deploy NodeLink to production with a handful of environment variables and be confident it'll run reliably.

**You can go from zero to streaming audio in about 5 minutes.**

---

## What's Next?

Now that NodeLink is containerized and running:

<Cards>
  <Card title="Connect Your Bot" href="/docs/api/websocket">
    Point your Discord bot at your NodeLink instance. Use the WebSocket API to manage players.
  </Card>
  <Card title="Configure Sources" href="/docs/config">
    Enable Spotify, Apple Music, or other sources. Configure API keys and credentials.
  </Card>
  <Card title="Set Up Monitoring" href="/docs/advenced/prometheus">
    Add Prometheus metrics and Grafana dashboards. Know exactly how your instance is performing.
  </Card>
  <Card title="Explore Features" href="/docs/api/nodelink-features">
    Try lyrics support, chapter markers, direct streaming, and NodeLink-exclusive filters.
  </Card>
</Cards>

The code is open. The configs are documented. The community is active. Go build something cool with it. üíô
